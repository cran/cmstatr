<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Stefan Kloppenborg" />


<title>cmstatr Tutorial</title>

<script>// Hide empty <a> tag within highlighted CodeBlock for screen reader accessibility (see https://github.com/jgm/pandoc/issues/6352#issuecomment-626106786) -->
// v0.0.1
// Written by JooYoung Seo (jooyoung@psu.edu) and Atsushi Yasumoto on June 1st, 2020.

document.addEventListener('DOMContentLoaded', function() {
  const codeList = document.getElementsByClassName("sourceCode");
  for (var i = 0; i < codeList.length; i++) {
    var linkList = codeList[i].getElementsByTagName('a');
    for (var j = 0; j < linkList.length; j++) {
      if (linkList[j].innerHTML === "") {
        linkList[j].setAttribute('aria-hidden', 'true');
      }
    }
  }
});
</script>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">cmstatr Tutorial</h1>
<h4 class="author">Stefan Kloppenborg</h4>
<h4 class="date">1-Apr-2020</h4>



<p><code>cmstatr</code> is an R package for analyzing composite material data for use in the aerospace industry. The statistical methods are based on those published in <a href="https://www.cmh17.org/">CMH-17-1G</a>. This package is intended to facilitate reproducible statistical analysis of composite materials. In this tutorial, we’ll explore the basic functionality of <code>cmstatr</code>.</p>
<p>Before we can actually use the package, we’ll need to load it. We’ll also load the <code>dplyr</code> package, which we’ll talk about shortly. There are also a few other packages that we’ll load. These could all be loaded by loading the <code>tidyverse</code> package instead.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">library</span>(cmstatr)</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="kw">library</span>(dplyr)</span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">library</span>(ggplot2)</span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="kw">library</span>(tidyr)</span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="kw">library</span>(purrr)</span></code></pre></div>
<div id="input-data" class="section level1">
<h1>Input Data</h1>
<p><code>cmstatr</code> is built with the assumption that the data is in (so called) <a href="http://vita.had.co.nz/papers/tidy-data.html">tidy data</a> format. This means that the data is in a data frame and that each observation (i.e. test result) has its own row and that each variable has its own column. Included in this package is a sample composite material data set (this data set is fictional: don’t use it for anything other than learning this package). The data set <code>carbon.fabric.2</code> has the expected format. We’ll just show the first 10 rows of the data for now.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a>carbon.fabric<span class="fl">.2</span> <span class="op">%&gt;%</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="st">  </span><span class="kw">head</span>(<span class="dv">10</span>)</span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="co">#&gt;    test condition batch thickness nplies strength modulus failure_mode</span></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="co">#&gt; 1    WT       CTD     A     0.112     14  142.817   9.285          LAT</span></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="co">#&gt; 2    WT       CTD     A     0.113     14  135.901   9.133          LAT</span></span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="co">#&gt; 3    WT       CTD     A     0.113     14  132.511   9.253          LAT</span></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="co">#&gt; 4    WT       CTD     A     0.112     14  135.586   9.150          LAB</span></span>
<span id="cb2-8"><a href="#cb2-8"></a><span class="co">#&gt; 5    WT       CTD     A     0.113     14  125.145   9.270          LAB</span></span>
<span id="cb2-9"><a href="#cb2-9"></a><span class="co">#&gt; 6    WT       CTD     A     0.113     14  135.203   9.189          LGM</span></span>
<span id="cb2-10"><a href="#cb2-10"></a><span class="co">#&gt; 7    WT       CTD     A     0.113     14  128.547   9.088          LAB</span></span>
<span id="cb2-11"><a href="#cb2-11"></a><span class="co">#&gt; 8    WT       CTD     B     0.113     14  127.709   9.199          LGM</span></span>
<span id="cb2-12"><a href="#cb2-12"></a><span class="co">#&gt; 9    WT       CTD     B     0.113     14  127.074   9.058          LGM</span></span>
<span id="cb2-13"><a href="#cb2-13"></a><span class="co">#&gt; 10   WT       CTD     B     0.114     14  126.879   9.306          LGM</span></span></code></pre></div>
<p>If your data set is not yet in this type of format (note: that the column names <em>do not</em> need to match the column names in the example), there are many ways to get it into this format. One of the easier ways of doing so is to use the <a href="https://tidyr.tidyverse.org/"><code>tidyr</code></a> package. The use of this package is outside the scope of this vignette.</p>
</div>
<div id="working-with-data" class="section level1">
<h1>Working With Data</h1>
<p>Throughout this vignette, we will be using some of the <code>tidyverse</code> tools for working with data. There are several ways to work with data in R, but in the opinion of the author of this vignette, the <code>tidyverse</code> provides the easiest way to do so. As such, this is the approach used in this vignette. Feel free to use whichever approach works best for you.</p>
</div>
<div id="normalizing-data-to-cured-ply-thickness" class="section level1">
<h1>Normalizing Data to Cured Ply Thickness</h1>
<p>Very often, you’ll want to normalize as-measured strength data to a nominal cured ply thickness for fiber-dominated properties. Very often, this will reduce the apparent variance in the data. The <code>normalize_ply_thickness</code> function can be used to normalize strength or modulus data to a certain cured ply thickness. This function takes three arguments: the value to normalize (i.e.. strength or modulus), the measured thickness and the nominal thickness. In our case, the nominal cured ply thickness of the material is <span class="math inline">\(0.0079\)</span>. We can then normalize the warp-tension and fill-compression data as follows:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1"></a>norm_data &lt;-<span class="st"> </span>carbon.fabric<span class="fl">.2</span> <span class="op">%&gt;%</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="st">  </span><span class="kw">filter</span>(test <span class="op">==</span><span class="st"> &quot;WT&quot;</span> <span class="op">|</span><span class="st"> </span>test <span class="op">==</span><span class="st"> &quot;FC&quot;</span>) <span class="op">%&gt;%</span></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">strength.norm =</span> <span class="kw">normalize_ply_thickness</span>(strength,</span>
<span id="cb3-4"><a href="#cb3-4"></a>                                                 thickness <span class="op">/</span><span class="st"> </span>nplies,</span>
<span id="cb3-5"><a href="#cb3-5"></a>                                                 <span class="fl">0.0079</span>))</span>
<span id="cb3-6"><a href="#cb3-6"></a></span>
<span id="cb3-7"><a href="#cb3-7"></a>norm_data <span class="op">%&gt;%</span></span>
<span id="cb3-8"><a href="#cb3-8"></a><span class="st">  </span><span class="kw">head</span>(<span class="dv">10</span>)</span>
<span id="cb3-9"><a href="#cb3-9"></a><span class="co">#&gt;    test condition batch thickness nplies strength modulus failure_mode</span></span>
<span id="cb3-10"><a href="#cb3-10"></a><span class="co">#&gt; 1    WT       CTD     A     0.112     14  142.817   9.285          LAT</span></span>
<span id="cb3-11"><a href="#cb3-11"></a><span class="co">#&gt; 2    WT       CTD     A     0.113     14  135.901   9.133          LAT</span></span>
<span id="cb3-12"><a href="#cb3-12"></a><span class="co">#&gt; 3    WT       CTD     A     0.113     14  132.511   9.253          LAT</span></span>
<span id="cb3-13"><a href="#cb3-13"></a><span class="co">#&gt; 4    WT       CTD     A     0.112     14  135.586   9.150          LAB</span></span>
<span id="cb3-14"><a href="#cb3-14"></a><span class="co">#&gt; 5    WT       CTD     A     0.113     14  125.145   9.270          LAB</span></span>
<span id="cb3-15"><a href="#cb3-15"></a><span class="co">#&gt; 6    WT       CTD     A     0.113     14  135.203   9.189          LGM</span></span>
<span id="cb3-16"><a href="#cb3-16"></a><span class="co">#&gt; 7    WT       CTD     A     0.113     14  128.547   9.088          LAB</span></span>
<span id="cb3-17"><a href="#cb3-17"></a><span class="co">#&gt; 8    WT       CTD     B     0.113     14  127.709   9.199          LGM</span></span>
<span id="cb3-18"><a href="#cb3-18"></a><span class="co">#&gt; 9    WT       CTD     B     0.113     14  127.074   9.058          LGM</span></span>
<span id="cb3-19"><a href="#cb3-19"></a><span class="co">#&gt; 10   WT       CTD     B     0.114     14  126.879   9.306          LGM</span></span>
<span id="cb3-20"><a href="#cb3-20"></a><span class="co">#&gt;    strength.norm</span></span>
<span id="cb3-21"><a href="#cb3-21"></a><span class="co">#&gt; 1       144.6248</span></span>
<span id="cb3-22"><a href="#cb3-22"></a><span class="co">#&gt; 2       138.8500</span></span>
<span id="cb3-23"><a href="#cb3-23"></a><span class="co">#&gt; 3       135.3865</span></span>
<span id="cb3-24"><a href="#cb3-24"></a><span class="co">#&gt; 4       137.3023</span></span>
<span id="cb3-25"><a href="#cb3-25"></a><span class="co">#&gt; 5       127.8606</span></span>
<span id="cb3-26"><a href="#cb3-26"></a><span class="co">#&gt; 6       138.1369</span></span>
<span id="cb3-27"><a href="#cb3-27"></a><span class="co">#&gt; 7       131.3364</span></span>
<span id="cb3-28"><a href="#cb3-28"></a><span class="co">#&gt; 8       130.4803</span></span>
<span id="cb3-29"><a href="#cb3-29"></a><span class="co">#&gt; 9       129.8315</span></span>
<span id="cb3-30"><a href="#cb3-30"></a><span class="co">#&gt; 10      130.7794</span></span></code></pre></div>
</div>
<div id="calculating-single-point-basis-value" class="section level1">
<h1>Calculating Single-Point Basis Value</h1>
<p>The simplest thing that you will likely do is to calculate a basis value based of a set of numbers that you consider as unstructured data. An example of this would be calculating the B-Basis of the <code>RTD</code> warp tension (<code>WT</code>) data.</p>
<p>There are a number of diagnostic tests that we should run before actually calculating a B-Basis value. We’ll talk about those later, but for now, let’s just get right to checking how the data are distributed and calculating the B-Basis.</p>
<p>We’ll use an Anderson–Darling test to check if the data are normally distributed. The <code>cmstatr</code> package provides the function <code>anderson_darling_normal</code> and related functions for other distributions. We can run an Anderson–Darling test for normality on the warp tension RTD data as follows. We’ll perform this test on the normalized strength.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1"></a>norm_data <span class="op">%&gt;%</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="st">  </span><span class="kw">filter</span>(test <span class="op">==</span><span class="st"> &quot;WT&quot;</span> <span class="op">&amp;</span><span class="st"> </span>condition <span class="op">==</span><span class="st"> &quot;RTD&quot;</span>) <span class="op">%&gt;%</span></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="st">  </span><span class="kw">anderson_darling_normal</span>(strength.norm)</span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="co">#&gt; </span></span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="co">#&gt; Call:</span></span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="co">#&gt; anderson_darling_normal(data = ., x = strength.norm)</span></span>
<span id="cb4-7"><a href="#cb4-7"></a><span class="co">#&gt; </span></span>
<span id="cb4-8"><a href="#cb4-8"></a><span class="co">#&gt; Distribution:  Normal ( n = 28 ) </span></span>
<span id="cb4-9"><a href="#cb4-9"></a><span class="co">#&gt; Test statistic:  A = 0.3805995 </span></span>
<span id="cb4-10"><a href="#cb4-10"></a><span class="co">#&gt; OSL (p-value):  0.3132051  (assuming unknown parameters)</span></span>
<span id="cb4-11"><a href="#cb4-11"></a><span class="co">#&gt; Conclusion: Sample is drawn from a Normal distribution ( alpha = 0.05 )</span></span></code></pre></div>
<p>Now that we know that this data follows a normal distribution (since the observed significance level (OSL) of the Anderson–Darling test is greater than <span class="math inline">\(0.05\)</span>), we can proceed to calculate a basis value based based on the assumption of normally distributed data. The <code>cmstatr</code> package provides the function <code>basis_normal</code> as well as related functions for other distributions. By default, the B-Basis value is calculated, but other population proportions and confidence bounds can be specified (for example, specify <code>p = 0.99, conf = 0.99</code> for A-Basis).</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1"></a>norm_data <span class="op">%&gt;%</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="st">  </span><span class="kw">filter</span>(test <span class="op">==</span><span class="st"> &quot;WT&quot;</span> <span class="op">&amp;</span><span class="st"> </span>condition <span class="op">==</span><span class="st"> &quot;RTD&quot;</span>) <span class="op">%&gt;%</span></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="st">  </span><span class="kw">basis_normal</span>(strength.norm)</span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="co">#&gt; `outliers_within_batch` not run because parameter `batch` not specified</span></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="co">#&gt; `between_batch_variability` not run because parameter `batch` not specified</span></span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="co">#&gt; </span></span>
<span id="cb5-7"><a href="#cb5-7"></a><span class="co">#&gt; Call:</span></span>
<span id="cb5-8"><a href="#cb5-8"></a><span class="co">#&gt; basis_normal(data = ., x = strength.norm)</span></span>
<span id="cb5-9"><a href="#cb5-9"></a><span class="co">#&gt; </span></span>
<span id="cb5-10"><a href="#cb5-10"></a><span class="co">#&gt; Distribution:  Normal    ( n = 28 )</span></span>
<span id="cb5-11"><a href="#cb5-11"></a><span class="co">#&gt; B-Basis:   ( p = 0.9 , conf = 0.95 )</span></span>
<span id="cb5-12"><a href="#cb5-12"></a><span class="co">#&gt; 129.9583</span></span></code></pre></div>
<p>We see that the calculated B-Basis is <span class="math inline">\(129.96\)</span>. We also see two messages issued by the <code>cmstatr</code> package. These messages relate to the automated diagnostic tests performed by the basis calculation functions. In this case we see messages that two of the diagnostic tests were not performed because we didn’t specify the batch of each observation. The batch is not required for calculating single-point basis values, but it is required for performing batch-to-batch variability and within-batch outlier diagnostic tests.</p>
<p>The <code>basis_normal</code> function performs the following diagnostic tests by default:</p>
<ul>
<li>Within batch outliers using <code>maximum_normed_residual()</code></li>
<li>Between batch variability using <code>ad_ksample()</code></li>
<li>Outliers using <code>maximum_normed_residual()</code></li>
<li>Normality of data using <code>anderson_darling_normal()</code></li>
</ul>
<p>There are two ways that we can deal with the two messages that we see. We can pass in a column that specifies the batch for each observation, or we can override those two diagnostic tests so that <code>cmstatr</code> doesn’t run them.</p>
<p>To override the two diagnostic tests, we set the argument <code>override</code> to a list of the names of the diagnostic tests that we want to skip. The names of the diagnostic tests that were not run are shown between back-ticks (`) in the message. Our call to <code>basis_normal()</code> would be updated as follows:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1"></a>norm_data <span class="op">%&gt;%</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="st">  </span><span class="kw">filter</span>(test <span class="op">==</span><span class="st"> &quot;WT&quot;</span> <span class="op">&amp;</span><span class="st"> </span>condition <span class="op">==</span><span class="st"> &quot;RTD&quot;</span>) <span class="op">%&gt;%</span></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="st">  </span><span class="kw">basis_normal</span>(strength.norm, </span>
<span id="cb6-4"><a href="#cb6-4"></a>               <span class="dt">override =</span> <span class="kw">c</span>(<span class="st">&quot;outliers_within_batch&quot;</span>,</span>
<span id="cb6-5"><a href="#cb6-5"></a>                            <span class="st">&quot;between_batch_variability&quot;</span>))</span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="co">#&gt; </span></span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="co">#&gt; Call:</span></span>
<span id="cb6-8"><a href="#cb6-8"></a><span class="co">#&gt; basis_normal(data = ., x = strength.norm, override = c(&quot;outliers_within_batch&quot;, </span></span>
<span id="cb6-9"><a href="#cb6-9"></a><span class="co">#&gt;     &quot;between_batch_variability&quot;))</span></span>
<span id="cb6-10"><a href="#cb6-10"></a><span class="co">#&gt; </span></span>
<span id="cb6-11"><a href="#cb6-11"></a><span class="co">#&gt; Distribution:  Normal    ( n = 28 )</span></span>
<span id="cb6-12"><a href="#cb6-12"></a><span class="co">#&gt; The following diagnostic tests were overridden:</span></span>
<span id="cb6-13"><a href="#cb6-13"></a><span class="co">#&gt;     `outliers_within_batch`,</span></span>
<span id="cb6-14"><a href="#cb6-14"></a><span class="co">#&gt;     `between_batch_variability`</span></span>
<span id="cb6-15"><a href="#cb6-15"></a><span class="co">#&gt; B-Basis:   ( p = 0.9 , conf = 0.95 )</span></span>
<span id="cb6-16"><a href="#cb6-16"></a><span class="co">#&gt; 129.9583</span></span></code></pre></div>
<p>Obviously, you should be cautious about overriding the diagnostic tests. There are certainly times when it is appropriate to do so, but sound engineering judgment is required.</p>
<p>The better approach would be to specify the batch. This can be done as follows:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1"></a>norm_data <span class="op">%&gt;%</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="st">  </span><span class="kw">filter</span>(test <span class="op">==</span><span class="st"> &quot;WT&quot;</span> <span class="op">&amp;</span><span class="st"> </span>condition <span class="op">==</span><span class="st"> &quot;RTD&quot;</span>) <span class="op">%&gt;%</span></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="st">  </span><span class="kw">basis_normal</span>(strength.norm, batch)</span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="co">#&gt; Warning: `between_batch_variability` failed: Anderson-Darling k-Sample test</span></span>
<span id="cb7-5"><a href="#cb7-5"></a><span class="co">#&gt; indicates that batches are drawn from different distributions</span></span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="co">#&gt; </span></span>
<span id="cb7-7"><a href="#cb7-7"></a><span class="co">#&gt; Call:</span></span>
<span id="cb7-8"><a href="#cb7-8"></a><span class="co">#&gt; basis_normal(data = ., x = strength.norm, batch = batch)</span></span>
<span id="cb7-9"><a href="#cb7-9"></a><span class="co">#&gt; </span></span>
<span id="cb7-10"><a href="#cb7-10"></a><span class="co">#&gt; Distribution:  Normal    ( n = 28 )</span></span>
<span id="cb7-11"><a href="#cb7-11"></a><span class="co">#&gt; The following diagnostic tests failed:</span></span>
<span id="cb7-12"><a href="#cb7-12"></a><span class="co">#&gt;     `between_batch_variability`</span></span>
<span id="cb7-13"><a href="#cb7-13"></a><span class="co">#&gt; B-Basis:   ( p = 0.9 , conf = 0.95 )</span></span>
<span id="cb7-14"><a href="#cb7-14"></a><span class="co">#&gt; 129.9583</span></span></code></pre></div>
<p>Now that batch is specified, we see that one of the diagnostic tests actually fails: the Anderson–Darling k-Sample test shows that the batches are not drawn from the same (unspecified) distribution. We can run this diagnostic test directly to investigate further:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1"></a>norm_data <span class="op">%&gt;%</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="st">  </span><span class="kw">filter</span>(test <span class="op">==</span><span class="st"> &quot;WT&quot;</span> <span class="op">&amp;</span><span class="st"> </span>condition <span class="op">==</span><span class="st"> &quot;RTD&quot;</span>) <span class="op">%&gt;%</span></span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="st">  </span><span class="kw">ad_ksample</span>(strength.norm, batch)</span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="co">#&gt; </span></span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="co">#&gt; Call:</span></span>
<span id="cb8-6"><a href="#cb8-6"></a><span class="co">#&gt; ad_ksample(data = ., x = strength.norm, groups = batch)</span></span>
<span id="cb8-7"><a href="#cb8-7"></a><span class="co">#&gt; </span></span>
<span id="cb8-8"><a href="#cb8-8"></a><span class="co">#&gt; N = 28           k = 3            </span></span>
<span id="cb8-9"><a href="#cb8-9"></a><span class="co">#&gt; ADK = 6.65       p-value = 0.0025892 </span></span>
<span id="cb8-10"><a href="#cb8-10"></a><span class="co">#&gt; Conclusion: Samples do not come from the same distribution (alpha = 0.025 )</span></span></code></pre></div>
<p>For the Anderson–Darling k-Sample test, <span class="math inline">\(\alpha=0.025\)</span> is normally used. In this case the p-value is <span class="math inline">\(p=0.0026\)</span>, so it is no where near <span class="math inline">\(\alpha\)</span> (note the number of decimal places).</p>
<p>We can plot the distribution of this data and make a judgment call about whether to continue.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1"></a>norm_data <span class="op">%&gt;%</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="st">  </span><span class="kw">filter</span>(test <span class="op">==</span><span class="st"> &quot;WT&quot;</span> <span class="op">&amp;</span><span class="st"> </span>condition <span class="op">==</span><span class="st"> &quot;RTD&quot;</span>) <span class="op">%&gt;%</span></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="st">  </span><span class="kw">group_by</span>(batch) <span class="op">%&gt;%</span></span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> strength.norm, <span class="dt">color =</span> batch)) <span class="op">+</span></span>
<span id="cb9-5"><a href="#cb9-5"></a><span class="st">  </span><span class="kw">stat_normal_surv_func</span>() <span class="op">+</span></span>
<span id="cb9-6"><a href="#cb9-6"></a><span class="st">  </span><span class="kw">stat_esf</span>() <span class="op">+</span></span>
<span id="cb9-7"><a href="#cb9-7"></a><span class="st">  </span><span class="kw">ggtitle</span>(<span class="st">&quot;Distribution of Data For Each Batch&quot;</span>)</span></code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<p>We can also run the other diagnostic test by themselves. These are described in more detail in the following sections.</p>
</div>
<div id="calculating-basis-values-by-pooling-across-environments" class="section level1">
<h1>Calculating Basis Values by Pooling Across Environments</h1>
<p>In this section, we’ll use the fill-compression data from the <code>carbon.fabric.2</code> data set.</p>
<div id="checking-for-outliers" class="section level2">
<h2>Checking for Outliers</h2>
<p>After checking that there are a sufficient number of conditions, batches and specimens and that the failure modes are consistent, we would normally check if there are outliers within each batch and condition. The maximum normed residual test can be used for this. The <code>cmstatr</code> package provides the function <code>maximum_normed_residual</code> to do this. First, we’ll group the data by condition and batch, then run the test on each group. The <code>maximum_normed_residual</code> function returns an object that contains a number of values. We’ll create a <code>data.frame</code> that contains those values.</p>
<p>In order to do this, we need to use the <code>nest</code> function from the <code>tidyr</code> package. This is explained in detail <a href="https://tidyr.tidyverse.org/articles/nest.html">here</a>. Basically, <code>nest</code> allows a column of <code>list</code>s or a column of <code>data.frame</code>s to be added to a <code>data.frame</code>. Once nested, we can use the <code>glance</code> method to unpack the values returned by <code>maximum_normed_residual</code> into a one-row <code>data.frame</code>, and then use <code>unnest</code> to flatten this into a single <code>data.frame</code>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1"></a>norm_data <span class="op">%&gt;%</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="st">  </span><span class="kw">filter</span>(test <span class="op">==</span><span class="st"> &quot;FC&quot;</span>) <span class="op">%&gt;%</span></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="st">  </span><span class="kw">group_by</span>(condition, batch) <span class="op">%&gt;%</span></span>
<span id="cb10-4"><a href="#cb10-4"></a><span class="st">  </span><span class="kw">nest</span>() <span class="op">%&gt;%</span></span>
<span id="cb10-5"><a href="#cb10-5"></a><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">mnr =</span> <span class="kw">map</span>(data,</span>
<span id="cb10-6"><a href="#cb10-6"></a>                   <span class="op">~</span><span class="kw">maximum_normed_residual</span>(<span class="dt">data =</span> .x, <span class="dt">x =</span> strength.norm)),</span>
<span id="cb10-7"><a href="#cb10-7"></a>         <span class="dt">tidied =</span> <span class="kw">map</span>(mnr, glance)) <span class="op">%&gt;%</span></span>
<span id="cb10-8"><a href="#cb10-8"></a><span class="st">  </span><span class="kw">select</span>(<span class="op">-</span><span class="kw">c</span>(mnr, data)) <span class="op">%&gt;%</span><span class="st">  </span><span class="co"># remove unneeded columns</span></span>
<span id="cb10-9"><a href="#cb10-9"></a><span class="st">  </span><span class="kw">unnest</span>(tidied)</span>
<span id="cb10-10"><a href="#cb10-10"></a><span class="co">#&gt; # A tibble: 15 x 6</span></span>
<span id="cb10-11"><a href="#cb10-11"></a><span class="co">#&gt; # Groups:   condition, batch [15]</span></span>
<span id="cb10-12"><a href="#cb10-12"></a><span class="co">#&gt;    condition batch   mnr alpha  crit n_outliers</span></span>
<span id="cb10-13"><a href="#cb10-13"></a><span class="co">#&gt;    &lt;chr&gt;     &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt;</span></span>
<span id="cb10-14"><a href="#cb10-14"></a><span class="co">#&gt;  1 CTD       A      1.48  0.05  1.89          0</span></span>
<span id="cb10-15"><a href="#cb10-15"></a><span class="co">#&gt;  2 CTD       B      1.72  0.05  1.89          0</span></span>
<span id="cb10-16"><a href="#cb10-16"></a><span class="co">#&gt;  3 CTD       C      1.52  0.05  1.89          0</span></span>
<span id="cb10-17"><a href="#cb10-17"></a><span class="co">#&gt;  4 RTD       A      1.34  0.05  1.89          0</span></span>
<span id="cb10-18"><a href="#cb10-18"></a><span class="co">#&gt;  5 RTD       B      1.47  0.05  1.89          0</span></span>
<span id="cb10-19"><a href="#cb10-19"></a><span class="co">#&gt;  6 RTD       C      1.52  0.05  1.89          0</span></span>
<span id="cb10-20"><a href="#cb10-20"></a><span class="co">#&gt;  7 ETD       A      1.66  0.05  1.89          0</span></span>
<span id="cb10-21"><a href="#cb10-21"></a><span class="co">#&gt;  8 ETD       B      1.53  0.05  1.89          0</span></span>
<span id="cb10-22"><a href="#cb10-22"></a><span class="co">#&gt;  9 ETD       C      1.40  0.05  1.89          0</span></span>
<span id="cb10-23"><a href="#cb10-23"></a><span class="co">#&gt; 10 ETW       A      1.45  0.05  1.89          0</span></span>
<span id="cb10-24"><a href="#cb10-24"></a><span class="co">#&gt; 11 ETW       B      1.83  0.05  1.89          0</span></span>
<span id="cb10-25"><a href="#cb10-25"></a><span class="co">#&gt; 12 ETW       C      1.76  0.05  1.89          0</span></span>
<span id="cb10-26"><a href="#cb10-26"></a><span class="co">#&gt; 13 ETW2      A      1.85  0.05  1.89          0</span></span>
<span id="cb10-27"><a href="#cb10-27"></a><span class="co">#&gt; 14 ETW2      B      1.54  0.05  1.89          0</span></span>
<span id="cb10-28"><a href="#cb10-28"></a><span class="co">#&gt; 15 ETW2      C      1.38  0.05  2.02          0</span></span></code></pre></div>
<p>None of the groups have outliers, so we can continue.</p>
</div>
</div>
<div id="batch-to-batch-distribution" class="section level1">
<h1>Batch-to-Batch Distribution</h1>
<p>Next, we will use the Anderson–Darling k-Sample test to check that each batch comes from the same distribution within each condition. We can use the <code>ad_ksample</code> function from <code>cmstatr</code> to do so. Once again, we’ll use <code>nest</code>/<code>unnest</code> and <code>glance</code> to do so.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1"></a>norm_data <span class="op">%&gt;%</span></span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="st">  </span><span class="kw">filter</span>(test <span class="op">==</span><span class="st"> &quot;FC&quot;</span>) <span class="op">%&gt;%</span></span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="st">  </span><span class="kw">group_by</span>(condition) <span class="op">%&gt;%</span></span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="st">  </span><span class="kw">nest</span>() <span class="op">%&gt;%</span></span>
<span id="cb11-5"><a href="#cb11-5"></a><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">adk =</span> <span class="kw">map</span>(data, <span class="op">~</span><span class="kw">ad_ksample</span>(<span class="dt">data =</span> .x,</span>
<span id="cb11-6"><a href="#cb11-6"></a>                                     <span class="dt">x =</span> strength.norm,</span>
<span id="cb11-7"><a href="#cb11-7"></a>                                     <span class="dt">groups =</span> batch)),</span>
<span id="cb11-8"><a href="#cb11-8"></a>         <span class="dt">tidied =</span> <span class="kw">map</span>(adk, glance)) <span class="op">%&gt;%</span></span>
<span id="cb11-9"><a href="#cb11-9"></a><span class="st">  </span><span class="kw">select</span>(<span class="op">-</span><span class="kw">c</span>(data, adk)) <span class="op">%&gt;%</span><span class="st">  </span><span class="co"># remove unneeded columns</span></span>
<span id="cb11-10"><a href="#cb11-10"></a><span class="st">  </span><span class="kw">unnest</span>(tidied)</span>
<span id="cb11-11"><a href="#cb11-11"></a><span class="co">#&gt; # A tibble: 5 x 8</span></span>
<span id="cb11-12"><a href="#cb11-12"></a><span class="co">#&gt; # Groups:   condition [5]</span></span>
<span id="cb11-13"><a href="#cb11-13"></a><span class="co">#&gt;   condition alpha     n     k sigma    ad     p reject_same_dist</span></span>
<span id="cb11-14"><a href="#cb11-14"></a><span class="co">#&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt;           </span></span>
<span id="cb11-15"><a href="#cb11-15"></a><span class="co">#&gt; 1 CTD       0.025    18     3 0.944 1.76  0.505 FALSE           </span></span>
<span id="cb11-16"><a href="#cb11-16"></a><span class="co">#&gt; 2 RTD       0.025    18     3 0.944 1.03  0.918 FALSE           </span></span>
<span id="cb11-17"><a href="#cb11-17"></a><span class="co">#&gt; 3 ETD       0.025    18     3 0.944 0.683 0.997 FALSE           </span></span>
<span id="cb11-18"><a href="#cb11-18"></a><span class="co">#&gt; 4 ETW       0.025    18     3 0.944 0.93  0.954 FALSE           </span></span>
<span id="cb11-19"><a href="#cb11-19"></a><span class="co">#&gt; 5 ETW2      0.025    19     3 0.951 1.74  0.513 FALSE</span></span></code></pre></div>
<p>For all conditions, the Anderson–Darling k-Sample test fails to reject the hypothesis that each batch comes from the same (unspecified) distribution. We can thus proceed to pooling the data.</p>
<div id="checking-for-outliers-within-each-condition" class="section level2">
<h2>Checking for Outliers Within Each Condition</h2>
<p>Just as we did when checking for outlier within each condition and each batch, we can pool all the batches (within each condition) and check for outliers within each condition.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1"></a>norm_data <span class="op">%&gt;%</span></span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="st">  </span><span class="kw">filter</span>(test <span class="op">==</span><span class="st"> &quot;FC&quot;</span>) <span class="op">%&gt;%</span></span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="st">  </span><span class="kw">group_by</span>(condition) <span class="op">%&gt;%</span></span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="st">  </span><span class="kw">nest</span>() <span class="op">%&gt;%</span></span>
<span id="cb12-5"><a href="#cb12-5"></a><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">mnr =</span> <span class="kw">map</span>(data, <span class="op">~</span><span class="kw">maximum_normed_residual</span>(<span class="dt">data =</span> .x,</span>
<span id="cb12-6"><a href="#cb12-6"></a>                                                  <span class="dt">x =</span> strength.norm)),</span>
<span id="cb12-7"><a href="#cb12-7"></a>         <span class="dt">tidied =</span> <span class="kw">map</span>(mnr, glance)) <span class="op">%&gt;%</span></span>
<span id="cb12-8"><a href="#cb12-8"></a><span class="st">  </span><span class="kw">select</span>(<span class="op">-</span><span class="kw">c</span>(mnr, data)) <span class="op">%&gt;%</span><span class="st">  </span><span class="co"># remove unneeded columns</span></span>
<span id="cb12-9"><a href="#cb12-9"></a><span class="st">  </span><span class="kw">unnest</span>(tidied)</span>
<span id="cb12-10"><a href="#cb12-10"></a><span class="co">#&gt; # A tibble: 5 x 5</span></span>
<span id="cb12-11"><a href="#cb12-11"></a><span class="co">#&gt; # Groups:   condition [5]</span></span>
<span id="cb12-12"><a href="#cb12-12"></a><span class="co">#&gt;   condition   mnr alpha  crit n_outliers</span></span>
<span id="cb12-13"><a href="#cb12-13"></a><span class="co">#&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt;</span></span>
<span id="cb12-14"><a href="#cb12-14"></a><span class="co">#&gt; 1 CTD        2.38  0.05  2.65          0</span></span>
<span id="cb12-15"><a href="#cb12-15"></a><span class="co">#&gt; 2 RTD        2.06  0.05  2.65          0</span></span>
<span id="cb12-16"><a href="#cb12-16"></a><span class="co">#&gt; 3 ETD        2.05  0.05  2.65          0</span></span>
<span id="cb12-17"><a href="#cb12-17"></a><span class="co">#&gt; 4 ETW        2.34  0.05  2.65          0</span></span>
<span id="cb12-18"><a href="#cb12-18"></a><span class="co">#&gt; 5 ETW2       2.07  0.05  2.68          0</span></span></code></pre></div>
<p>We find no outliers, so we can continue.</p>
</div>
<div id="pooling-across-environments" class="section level2">
<h2>Pooling Across Environments</h2>
<p>Often it is desirable to pool data across several environments. There are two methods for doing so: “pooled standard deviation” and “pooled CV” (CV is an abbreviation for Coefficient of Variation)</p>
<p>First, we will check for equality of variance among the conditions. We will do so using Levene’s test. The <code>cmstatr</code> package provides the function <code>levene_test</code> to do so.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1"></a>norm_data <span class="op">%&gt;%</span></span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="st">  </span><span class="kw">filter</span>(test <span class="op">==</span><span class="st"> &quot;FC&quot;</span>) <span class="op">%&gt;%</span></span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="st">  </span><span class="kw">levene_test</span>(strength.norm, condition)</span>
<span id="cb13-4"><a href="#cb13-4"></a><span class="co">#&gt; </span></span>
<span id="cb13-5"><a href="#cb13-5"></a><span class="co">#&gt; Call:</span></span>
<span id="cb13-6"><a href="#cb13-6"></a><span class="co">#&gt; levene_test(data = ., x = strength.norm, groups = condition)</span></span>
<span id="cb13-7"><a href="#cb13-7"></a><span class="co">#&gt; </span></span>
<span id="cb13-8"><a href="#cb13-8"></a><span class="co">#&gt; n = 91           k = 5            </span></span>
<span id="cb13-9"><a href="#cb13-9"></a><span class="co">#&gt; F = 5.260731     p-value = 0.0007727083 </span></span>
<span id="cb13-10"><a href="#cb13-10"></a><span class="co">#&gt; Conclusion: Samples have unequal variance ( alpha = 0.05 )</span></span></code></pre></div>
<p>The result from Levene’s test indicates that the variance for each condition is not equal. This indicates that the data cannot be pooled using the “pooled standard deviation” method.</p>
<p>We can check if the data can be pooled using the “pooled CV” method. We’ll start by normalizing the data from each group to the group’s mean. The <code>cmstatr</code> package provides the function <code>normalize_group_mean</code> for this purpose.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1"></a>norm_data <span class="op">%&gt;%</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="st">  </span><span class="kw">filter</span>(test <span class="op">==</span><span class="st"> &quot;FC&quot;</span>) <span class="op">%&gt;%</span></span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="st">  </span><span class="kw">mutate</span>(</span>
<span id="cb14-4"><a href="#cb14-4"></a>    <span class="dt">strength_norm_group =</span> <span class="kw">normalize_group_mean</span>(strength.norm, condition)) <span class="op">%&gt;%</span></span>
<span id="cb14-5"><a href="#cb14-5"></a><span class="st">  </span><span class="kw">levene_test</span>(strength_norm_group, condition)</span>
<span id="cb14-6"><a href="#cb14-6"></a><span class="co">#&gt; </span></span>
<span id="cb14-7"><a href="#cb14-7"></a><span class="co">#&gt; Call:</span></span>
<span id="cb14-8"><a href="#cb14-8"></a><span class="co">#&gt; levene_test(data = ., x = strength_norm_group, groups = condition)</span></span>
<span id="cb14-9"><a href="#cb14-9"></a><span class="co">#&gt; </span></span>
<span id="cb14-10"><a href="#cb14-10"></a><span class="co">#&gt; n = 91           k = 5            </span></span>
<span id="cb14-11"><a href="#cb14-11"></a><span class="co">#&gt; F = 1.839645     p-value = 0.1285863 </span></span>
<span id="cb14-12"><a href="#cb14-12"></a><span class="co">#&gt; Conclusion: Samples have equal variances ( alpha = 0.05 )</span></span></code></pre></div>
<p>The Levene’s test thus shows the variances of the pooled data are equal. We can move on to performing an Anderson–Darling test for normality on the pooled data.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1"></a>norm_data <span class="op">%&gt;%</span></span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="st">  </span><span class="kw">filter</span>(test <span class="op">==</span><span class="st"> &quot;FC&quot;</span>) <span class="op">%&gt;%</span></span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="st">  </span><span class="kw">mutate</span>(</span>
<span id="cb15-4"><a href="#cb15-4"></a>    <span class="dt">strength_norm_group =</span> <span class="kw">normalize_group_mean</span>(strength.norm, condition)) <span class="op">%&gt;%</span></span>
<span id="cb15-5"><a href="#cb15-5"></a><span class="st">  </span><span class="kw">anderson_darling_normal</span>(strength_norm_group)</span>
<span id="cb15-6"><a href="#cb15-6"></a><span class="co">#&gt; </span></span>
<span id="cb15-7"><a href="#cb15-7"></a><span class="co">#&gt; Call:</span></span>
<span id="cb15-8"><a href="#cb15-8"></a><span class="co">#&gt; anderson_darling_normal(data = ., x = strength_norm_group)</span></span>
<span id="cb15-9"><a href="#cb15-9"></a><span class="co">#&gt; </span></span>
<span id="cb15-10"><a href="#cb15-10"></a><span class="co">#&gt; Distribution:  Normal ( n = 91 ) </span></span>
<span id="cb15-11"><a href="#cb15-11"></a><span class="co">#&gt; Test statistic:  A = 0.3619689 </span></span>
<span id="cb15-12"><a href="#cb15-12"></a><span class="co">#&gt; OSL (p-value):  0.3812268  (assuming unknown parameters)</span></span>
<span id="cb15-13"><a href="#cb15-13"></a><span class="co">#&gt; Conclusion: Sample is drawn from a Normal distribution ( alpha = 0.05 )</span></span></code></pre></div>
<p>The Anderson–Darling test indicates that the pooled data is drawn from a normal distribution, so we can continue with calculating basis values using the “pooled CV” method.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1"></a>norm_data <span class="op">%&gt;%</span></span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="st">  </span><span class="kw">filter</span>(test <span class="op">==</span><span class="st"> &quot;FC&quot;</span>) <span class="op">%&gt;%</span></span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="st">  </span><span class="kw">basis_pooled_cv</span>(strength.norm, condition, batch)</span>
<span id="cb16-4"><a href="#cb16-4"></a><span class="co">#&gt; </span></span>
<span id="cb16-5"><a href="#cb16-5"></a><span class="co">#&gt; Call:</span></span>
<span id="cb16-6"><a href="#cb16-6"></a><span class="co">#&gt; basis_pooled_cv(data = ., x = strength.norm, groups = condition, </span></span>
<span id="cb16-7"><a href="#cb16-7"></a><span class="co">#&gt;     batch = batch)</span></span>
<span id="cb16-8"><a href="#cb16-8"></a><span class="co">#&gt; </span></span>
<span id="cb16-9"><a href="#cb16-9"></a><span class="co">#&gt; Distribution:  Normal - Pooled CV    ( n = 91, r = 5 )</span></span>
<span id="cb16-10"><a href="#cb16-10"></a><span class="co">#&gt; B-Basis:   ( p = 0.9 , conf = 0.95 )</span></span>
<span id="cb16-11"><a href="#cb16-11"></a><span class="co">#&gt; CTD   85.09241 </span></span>
<span id="cb16-12"><a href="#cb16-12"></a><span class="co">#&gt; ETD   66.55109 </span></span>
<span id="cb16-13"><a href="#cb16-13"></a><span class="co">#&gt; ETW   51.43626 </span></span>
<span id="cb16-14"><a href="#cb16-14"></a><span class="co">#&gt; ETW2  45.81318 </span></span>
<span id="cb16-15"><a href="#cb16-15"></a><span class="co">#&gt; RTD   78.2274</span></span></code></pre></div>
<p>The conditions listed in the output above are in alphabetical order. This probably isn’t what you want. Instead, you probably want the conditions listed in a certain order. This can be done by ordering the data first as demonstrated below. You’re probably just do this one in at the start of your analysis.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1"></a>norm_data <span class="op">%&gt;%</span></span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">condition =</span> <span class="kw">ordered</span>(condition,</span>
<span id="cb17-3"><a href="#cb17-3"></a>                             <span class="kw">c</span>(<span class="st">&quot;CTD&quot;</span>, <span class="st">&quot;RTD&quot;</span>, <span class="st">&quot;ETD&quot;</span>, <span class="st">&quot;ETW&quot;</span>, <span class="st">&quot;ETW2&quot;</span>))) <span class="op">%&gt;%</span></span>
<span id="cb17-4"><a href="#cb17-4"></a><span class="st">  </span><span class="kw">filter</span>(test <span class="op">==</span><span class="st"> &quot;FC&quot;</span>) <span class="op">%&gt;%</span></span>
<span id="cb17-5"><a href="#cb17-5"></a><span class="st">  </span><span class="kw">basis_pooled_cv</span>(strength.norm, condition, batch)</span>
<span id="cb17-6"><a href="#cb17-6"></a><span class="co">#&gt; </span></span>
<span id="cb17-7"><a href="#cb17-7"></a><span class="co">#&gt; Call:</span></span>
<span id="cb17-8"><a href="#cb17-8"></a><span class="co">#&gt; basis_pooled_cv(data = ., x = strength.norm, groups = condition, </span></span>
<span id="cb17-9"><a href="#cb17-9"></a><span class="co">#&gt;     batch = batch)</span></span>
<span id="cb17-10"><a href="#cb17-10"></a><span class="co">#&gt; </span></span>
<span id="cb17-11"><a href="#cb17-11"></a><span class="co">#&gt; Distribution:  Normal - Pooled CV    ( n = 91, r = 5 )</span></span>
<span id="cb17-12"><a href="#cb17-12"></a><span class="co">#&gt; B-Basis:   ( p = 0.9 , conf = 0.95 )</span></span>
<span id="cb17-13"><a href="#cb17-13"></a><span class="co">#&gt; CTD   85.09241 </span></span>
<span id="cb17-14"><a href="#cb17-14"></a><span class="co">#&gt; RTD   78.2274 </span></span>
<span id="cb17-15"><a href="#cb17-15"></a><span class="co">#&gt; ETD   66.55109 </span></span>
<span id="cb17-16"><a href="#cb17-16"></a><span class="co">#&gt; ETW   51.43626 </span></span>
<span id="cb17-17"><a href="#cb17-17"></a><span class="co">#&gt; ETW2  45.81318</span></span></code></pre></div>
</div>
</div>
<div id="equivalency" class="section level1">
<h1>Equivalency</h1>
<p>Eventually, once you’ve finished calculating all your basis values, you’ll probably want to set specification requirements or evaluate site/process equivalency. <code>cmstatr</code> has functionality to do both.</p>
<p>Let’s say that you want to develop specification limits for fill compression that you’re going to put in your material specification. You can do this as follows:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1"></a>carbon.fabric<span class="fl">.2</span> <span class="op">%&gt;%</span></span>
<span id="cb18-2"><a href="#cb18-2"></a><span class="st">  </span><span class="kw">filter</span>(test <span class="op">==</span><span class="st"> &quot;FC&quot;</span> <span class="op">&amp;</span><span class="st"> </span>condition <span class="op">==</span><span class="st"> &quot;RTD&quot;</span>) <span class="op">%&gt;%</span></span>
<span id="cb18-3"><a href="#cb18-3"></a><span class="st">  </span><span class="kw">equiv_mean_extremum</span>(strength, <span class="dt">n_sample =</span> <span class="dv">5</span>, <span class="dt">alpha =</span> <span class="fl">0.01</span>)</span>
<span id="cb18-4"><a href="#cb18-4"></a><span class="co">#&gt; </span></span>
<span id="cb18-5"><a href="#cb18-5"></a><span class="co">#&gt; Call:</span></span>
<span id="cb18-6"><a href="#cb18-6"></a><span class="co">#&gt; equiv_mean_extremum(df_qual = ., data_qual = strength, n_sample = 5, </span></span>
<span id="cb18-7"><a href="#cb18-7"></a><span class="co">#&gt;     alpha = 0.01)</span></span>
<span id="cb18-8"><a href="#cb18-8"></a><span class="co">#&gt; </span></span>
<span id="cb18-9"><a href="#cb18-9"></a><span class="co">#&gt; For alpha = 0.01 and n = 5 </span></span>
<span id="cb18-10"><a href="#cb18-10"></a><span class="co">#&gt; ( k1 = 3.071482 and k2 = 1.142506 )</span></span>
<span id="cb18-11"><a href="#cb18-11"></a><span class="co">#&gt;                   Min Individual    Sample Mean    </span></span>
<span id="cb18-12"><a href="#cb18-12"></a><span class="co">#&gt;      Thresholds:     69.89842         82.16867</span></span></code></pre></div>
<p>If you’re determining equivalency limits for modulus, a different approach is generally used so that bilateral limits are set. <code>cmstatr</code> can do this as well, using the function <code>equiv_change_mean</code>.</p>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
