<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Stefan Kloppenborg" />


<title>cmstatr Tutorial</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">cmstatr Tutorial</h1>
<h4 class="author">Stefan Kloppenborg</h4>
<h4 class="date">1-Apr-2020</h4>



<p><code>cmstatr</code> is an R package for analyzing composite material
data for use in the aerospace industry. The statistical methods are
based on those published in <a href="https://www.cmh17.org/">CMH-17-1G</a>. This package is intended to
facilitate reproducible statistical analysis of composite materials. In
this tutorial, we’ll explore the basic functionality of
<code>cmstatr</code>.</p>
<p>Before we can actually use the package, we’ll need to load it. We’ll
also load the <code>dplyr</code> package, which we’ll talk about
shortly. There are also a few other packages that we’ll load. These
could all be loaded by loading the <code>tidyverse</code> package
instead.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">library</span>(cmstatr)</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="fu">library</span>(dplyr)</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="fu">library</span>(ggplot2)</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="fu">library</span>(tidyr)</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a><span class="fu">library</span>(purrr)</span></code></pre></div>
<div id="input-data" class="section level1">
<h1>Input Data</h1>
<p><code>cmstatr</code> is built with the assumption that the data is in
(so called) <a href="http://vita.had.co.nz/papers/tidy-data.html">tidy
data</a> format. This means that the data is in a data frame and that
each observation (i.e. test result) has its own row and that each
variable has its own column. Included in this package is a sample
composite material data set (this data set is fictional: don’t use it
for anything other than learning this package). The data set
<code>carbon.fabric.2</code> has the expected format. We’ll just show
the first 10 rows of the data for now.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a>carbon.fabric<span class="fl">.2</span> <span class="sc">%&gt;%</span></span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>  <span class="fu">head</span>(<span class="dv">10</span>)</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a><span class="co">#&gt;    test condition batch panel thickness nplies strength modulus failure_mode</span></span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a><span class="co">#&gt; 1    WT       CTD     A     1     0.112     14  142.817   9.285          LAT</span></span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a><span class="co">#&gt; 2    WT       CTD     A     1     0.113     14  135.901   9.133          LAT</span></span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a><span class="co">#&gt; 3    WT       CTD     A     1     0.113     14  132.511   9.253          LAT</span></span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a><span class="co">#&gt; 4    WT       CTD     A     2     0.112     14  135.586   9.150          LAB</span></span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a><span class="co">#&gt; 5    WT       CTD     A     2     0.113     14  125.145   9.270          LAB</span></span>
<span id="cb2-9"><a href="#cb2-9" tabindex="-1"></a><span class="co">#&gt; 6    WT       CTD     A     2     0.113     14  135.203   9.189          LGM</span></span>
<span id="cb2-10"><a href="#cb2-10" tabindex="-1"></a><span class="co">#&gt; 7    WT       CTD     A     2     0.113     14  128.547   9.088          LAB</span></span>
<span id="cb2-11"><a href="#cb2-11" tabindex="-1"></a><span class="co">#&gt; 8    WT       CTD     B     1     0.113     14  127.709   9.199          LGM</span></span>
<span id="cb2-12"><a href="#cb2-12" tabindex="-1"></a><span class="co">#&gt; 9    WT       CTD     B     1     0.113     14  127.074   9.058          LGM</span></span>
<span id="cb2-13"><a href="#cb2-13" tabindex="-1"></a><span class="co">#&gt; 10   WT       CTD     B     1     0.114     14  126.879   9.306          LGM</span></span></code></pre></div>
<p>If your data set is not yet in this type of format (note: that the
column names <em>do not</em> need to match the column names in the
example), there are many ways to get it into this format. One of the
easier ways of doing so is to use the <a href="https://tidyr.tidyverse.org/"><code>tidyr</code></a> package. The
use of this package is outside the scope of this vignette.</p>
</div>
<div id="working-with-data" class="section level1">
<h1>Working With Data</h1>
<p>Throughout this vignette, we will be using some of the
<code>tidyverse</code> tools for working with data. There are several
ways to work with data in R, but in the opinion of the author of this
vignette, the <code>tidyverse</code> provides the easiest way to do so.
As such, this is the approach used in this vignette. Feel free to use
whichever approach works best for you.</p>
</div>
<div id="normalizing-data-to-cured-ply-thickness" class="section level1">
<h1>Normalizing Data to Cured Ply Thickness</h1>
<p>Very often, you’ll want to normalize as-measured strength data to a
nominal cured ply thickness for fiber-dominated properties. Very often,
this will reduce the apparent variance in the data. The
<code>normalize_ply_thickness</code> function can be used to normalize
strength or modulus data to a certain cured ply thickness. This function
takes three arguments: the value to normalize (i.e.. strength or
modulus), the measured thickness and the nominal thickness. In our case,
the nominal cured ply thickness of the material is <span class="math inline">\(0.0079\)</span>. We can then normalize the
warp-tension and fill-compression data as follows:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a>norm_data <span class="ot">&lt;-</span> carbon.fabric<span class="fl">.2</span> <span class="sc">%&gt;%</span></span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>  <span class="fu">filter</span>(test <span class="sc">==</span> <span class="st">&quot;WT&quot;</span> <span class="sc">|</span> test <span class="sc">==</span> <span class="st">&quot;FC&quot;</span>) <span class="sc">%&gt;%</span></span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">strength.norm =</span> <span class="fu">normalize_ply_thickness</span>(strength,</span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a>                                                 thickness <span class="sc">/</span> nplies,</span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a>                                                 <span class="fl">0.0079</span>))</span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a>norm_data <span class="sc">%&gt;%</span></span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a>  <span class="fu">head</span>(<span class="dv">10</span>)</span>
<span id="cb3-9"><a href="#cb3-9" tabindex="-1"></a><span class="co">#&gt;    test condition batch panel thickness nplies strength modulus failure_mode</span></span>
<span id="cb3-10"><a href="#cb3-10" tabindex="-1"></a><span class="co">#&gt; 1    WT       CTD     A     1     0.112     14  142.817   9.285          LAT</span></span>
<span id="cb3-11"><a href="#cb3-11" tabindex="-1"></a><span class="co">#&gt; 2    WT       CTD     A     1     0.113     14  135.901   9.133          LAT</span></span>
<span id="cb3-12"><a href="#cb3-12" tabindex="-1"></a><span class="co">#&gt; 3    WT       CTD     A     1     0.113     14  132.511   9.253          LAT</span></span>
<span id="cb3-13"><a href="#cb3-13" tabindex="-1"></a><span class="co">#&gt; 4    WT       CTD     A     2     0.112     14  135.586   9.150          LAB</span></span>
<span id="cb3-14"><a href="#cb3-14" tabindex="-1"></a><span class="co">#&gt; 5    WT       CTD     A     2     0.113     14  125.145   9.270          LAB</span></span>
<span id="cb3-15"><a href="#cb3-15" tabindex="-1"></a><span class="co">#&gt; 6    WT       CTD     A     2     0.113     14  135.203   9.189          LGM</span></span>
<span id="cb3-16"><a href="#cb3-16" tabindex="-1"></a><span class="co">#&gt; 7    WT       CTD     A     2     0.113     14  128.547   9.088          LAB</span></span>
<span id="cb3-17"><a href="#cb3-17" tabindex="-1"></a><span class="co">#&gt; 8    WT       CTD     B     1     0.113     14  127.709   9.199          LGM</span></span>
<span id="cb3-18"><a href="#cb3-18" tabindex="-1"></a><span class="co">#&gt; 9    WT       CTD     B     1     0.113     14  127.074   9.058          LGM</span></span>
<span id="cb3-19"><a href="#cb3-19" tabindex="-1"></a><span class="co">#&gt; 10   WT       CTD     B     1     0.114     14  126.879   9.306          LGM</span></span>
<span id="cb3-20"><a href="#cb3-20" tabindex="-1"></a><span class="co">#&gt;    strength.norm</span></span>
<span id="cb3-21"><a href="#cb3-21" tabindex="-1"></a><span class="co">#&gt; 1       144.6248</span></span>
<span id="cb3-22"><a href="#cb3-22" tabindex="-1"></a><span class="co">#&gt; 2       138.8500</span></span>
<span id="cb3-23"><a href="#cb3-23" tabindex="-1"></a><span class="co">#&gt; 3       135.3865</span></span>
<span id="cb3-24"><a href="#cb3-24" tabindex="-1"></a><span class="co">#&gt; 4       137.3023</span></span>
<span id="cb3-25"><a href="#cb3-25" tabindex="-1"></a><span class="co">#&gt; 5       127.8606</span></span>
<span id="cb3-26"><a href="#cb3-26" tabindex="-1"></a><span class="co">#&gt; 6       138.1369</span></span>
<span id="cb3-27"><a href="#cb3-27" tabindex="-1"></a><span class="co">#&gt; 7       131.3364</span></span>
<span id="cb3-28"><a href="#cb3-28" tabindex="-1"></a><span class="co">#&gt; 8       130.4803</span></span>
<span id="cb3-29"><a href="#cb3-29" tabindex="-1"></a><span class="co">#&gt; 9       129.8315</span></span>
<span id="cb3-30"><a href="#cb3-30" tabindex="-1"></a><span class="co">#&gt; 10      130.7794</span></span></code></pre></div>
</div>
<div id="calculating-single-point-basis-value" class="section level1">
<h1>Calculating Single-Point Basis Value</h1>
<p>The simplest thing that you will likely do is to calculate a basis
value based of a set of numbers that you consider as unstructured data.
An example of this would be calculating the B-Basis of the
<code>RTD</code> warp tension (<code>WT</code>) data.</p>
<p>There are a number of diagnostic tests that we should run before
actually calculating a B-Basis value. We’ll talk about those later, but
for now, let’s just get right to checking how the data are distributed
and calculating the B-Basis.</p>
<p>We’ll use an Anderson–Darling test to check if the data are normally
distributed. The <code>cmstatr</code> package provides the function
<code>anderson_darling_normal</code> and related functions for other
distributions. We can run an Anderson–Darling test for normality on the
warp tension RTD data as follows. We’ll perform this test on the
normalized strength.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>norm_data <span class="sc">%&gt;%</span></span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>  <span class="fu">filter</span>(test <span class="sc">==</span> <span class="st">&quot;WT&quot;</span> <span class="sc">&amp;</span> condition <span class="sc">==</span> <span class="st">&quot;RTD&quot;</span>) <span class="sc">%&gt;%</span></span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a>  <span class="fu">anderson_darling_normal</span>(strength.norm)</span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a><span class="co">#&gt; Call:</span></span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a><span class="co">#&gt; anderson_darling_normal(data = ., x = strength.norm)</span></span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb4-8"><a href="#cb4-8" tabindex="-1"></a><span class="co">#&gt; Distribution:  Normal ( n = 28 ) </span></span>
<span id="cb4-9"><a href="#cb4-9" tabindex="-1"></a><span class="co">#&gt; Test statistic:  A = 0.3805995 </span></span>
<span id="cb4-10"><a href="#cb4-10" tabindex="-1"></a><span class="co">#&gt; OSL (p-value):  0.3132051  (assuming unknown parameters)</span></span>
<span id="cb4-11"><a href="#cb4-11" tabindex="-1"></a><span class="co">#&gt; Conclusion: Sample is drawn from a Normal distribution ( alpha = 0.05 )</span></span></code></pre></div>
<p>Now that we know that this data follows a normal distribution (since
the observed significance level (OSL) of the Anderson–Darling test is
greater than <span class="math inline">\(0.05\)</span>), we can proceed
to calculate a basis value based based on the assumption of normally
distributed data. The <code>cmstatr</code> package provides the function
<code>basis_normal</code> as well as related functions for other
distributions. By default, the B-Basis value is calculated, but other
population proportions and confidence bounds can be specified (for
example, specify <code>p = 0.99, conf = 0.99</code> for A-Basis).</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>norm_data <span class="sc">%&gt;%</span></span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>  <span class="fu">filter</span>(test <span class="sc">==</span> <span class="st">&quot;WT&quot;</span> <span class="sc">&amp;</span> condition <span class="sc">==</span> <span class="st">&quot;RTD&quot;</span>) <span class="sc">%&gt;%</span></span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>  <span class="fu">basis_normal</span>(strength.norm)</span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a><span class="co">#&gt; `outliers_within_batch` not run because parameter `batch` not specified</span></span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a><span class="co">#&gt; `between_batch_variability` not run because parameter `batch` not specified</span></span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a><span class="co">#&gt; Call:</span></span>
<span id="cb5-8"><a href="#cb5-8" tabindex="-1"></a><span class="co">#&gt; basis_normal(data = ., x = strength.norm)</span></span>
<span id="cb5-9"><a href="#cb5-9" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb5-10"><a href="#cb5-10" tabindex="-1"></a><span class="co">#&gt; Distribution:  Normal    ( n = 28 )</span></span>
<span id="cb5-11"><a href="#cb5-11" tabindex="-1"></a><span class="co">#&gt; B-Basis:   ( p = 0.9 , conf = 0.95 )</span></span>
<span id="cb5-12"><a href="#cb5-12" tabindex="-1"></a><span class="co">#&gt; 129.9583</span></span></code></pre></div>
<p>We see that the calculated B-Basis is <span class="math inline">\(129.96\)</span>. We also see two messages issued
by the <code>cmstatr</code> package. These messages relate to the
automated diagnostic tests performed by the basis calculation functions.
In this case we see messages that two of the diagnostic tests were not
performed because we didn’t specify the batch of each observation. The
batch is not required for calculating single-point basis values, but it
is required for performing batch-to-batch variability and within-batch
outlier diagnostic tests.</p>
<p>The <code>basis_normal</code> function performs the following
diagnostic tests by default:</p>
<ul>
<li>Within batch outliers using
<code>maximum_normed_residual()</code></li>
<li>Between batch variability using <code>ad_ksample()</code></li>
<li>Outliers using <code>maximum_normed_residual()</code></li>
<li>Normality of data using <code>anderson_darling_normal()</code></li>
</ul>
<p>There are two ways that we can deal with the two messages that we
see. We can pass in a column that specifies the batch for each
observation, or we can override those two diagnostic tests so that
<code>cmstatr</code> doesn’t run them.</p>
<p>To override the two diagnostic tests, we set the argument
<code>override</code> to a list of the names of the diagnostic tests
that we want to skip. The names of the diagnostic tests that were not
run are shown between back-ticks (`) in the message. Our call to
<code>basis_normal()</code> would be updated as follows:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a>norm_data <span class="sc">%&gt;%</span></span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>  <span class="fu">filter</span>(test <span class="sc">==</span> <span class="st">&quot;WT&quot;</span> <span class="sc">&amp;</span> condition <span class="sc">==</span> <span class="st">&quot;RTD&quot;</span>) <span class="sc">%&gt;%</span></span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a>  <span class="fu">basis_normal</span>(strength.norm, </span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a>               <span class="at">override =</span> <span class="fu">c</span>(<span class="st">&quot;outliers_within_batch&quot;</span>,</span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a>                            <span class="st">&quot;between_batch_variability&quot;</span>))</span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a><span class="co">#&gt; Call:</span></span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a><span class="co">#&gt; basis_normal(data = ., x = strength.norm, override = c(&quot;outliers_within_batch&quot;, </span></span>
<span id="cb6-9"><a href="#cb6-9" tabindex="-1"></a><span class="co">#&gt;     &quot;between_batch_variability&quot;))</span></span>
<span id="cb6-10"><a href="#cb6-10" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb6-11"><a href="#cb6-11" tabindex="-1"></a><span class="co">#&gt; Distribution:  Normal    ( n = 28 )</span></span>
<span id="cb6-12"><a href="#cb6-12" tabindex="-1"></a><span class="co">#&gt; The following diagnostic tests were overridden:</span></span>
<span id="cb6-13"><a href="#cb6-13" tabindex="-1"></a><span class="co">#&gt;     `outliers_within_batch`,</span></span>
<span id="cb6-14"><a href="#cb6-14" tabindex="-1"></a><span class="co">#&gt;     `between_batch_variability`</span></span>
<span id="cb6-15"><a href="#cb6-15" tabindex="-1"></a><span class="co">#&gt; B-Basis:   ( p = 0.9 , conf = 0.95 )</span></span>
<span id="cb6-16"><a href="#cb6-16" tabindex="-1"></a><span class="co">#&gt; 129.9583</span></span></code></pre></div>
<p>Obviously, you should be cautious about overriding the diagnostic
tests. There are certainly times when it is appropriate to do so, but
sound engineering judgment is required.</p>
<p>The better approach would be to specify the batch. This can be done
as follows. We’ll store the result in the variable
<code>b_basis_wt_rtd</code> for reasons that will become clear
later.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a>b_basis_wt_rtd <span class="ot">&lt;-</span> norm_data <span class="sc">%&gt;%</span></span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>  <span class="fu">filter</span>(test <span class="sc">==</span> <span class="st">&quot;WT&quot;</span> <span class="sc">&amp;</span> condition <span class="sc">==</span> <span class="st">&quot;RTD&quot;</span>) <span class="sc">%&gt;%</span></span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a>  <span class="fu">basis_normal</span>(strength.norm, batch)</span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a><span class="co">#&gt; Warning: `between_batch_variability` failed: Anderson-Darling k-Sample test</span></span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a><span class="co">#&gt; indicates that batches are drawn from different distributions</span></span></code></pre></div>
<p>Now that batch is specified, we see that one of the diagnostic tests
actually fails: the Anderson–Darling k-Sample test shows that the
batches are not drawn from the same (unspecified) distribution. We can
interrogate the failing test by accessing the
<code>diagnostic_obj</code> element of the return value from
<code>basis_normal()</code>. This contains elements for each of the
diagnostic tests. We can access the
<code>between_batch_variability</code> result as follows:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a>b_basis_wt_rtd<span class="sc">$</span>diagnostic_obj<span class="sc">$</span>between_batch_variability</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a><span class="co">#&gt; Call:</span></span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a><span class="co">#&gt; ad_ksample(x = x, groups = batch, alpha = 0.025)</span></span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a><span class="co">#&gt; N = 28           k = 3            </span></span>
<span id="cb8-7"><a href="#cb8-7" tabindex="-1"></a><span class="co">#&gt; ADK = 6.65       p-value = 0.0025892 </span></span>
<span id="cb8-8"><a href="#cb8-8" tabindex="-1"></a><span class="co">#&gt; Conclusion: Samples do not come from the same distribution (alpha = 0.025 )</span></span></code></pre></div>
<p>We could have also run the failing diagnostic test directly as
follows:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>norm_data <span class="sc">%&gt;%</span></span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>  <span class="fu">filter</span>(test <span class="sc">==</span> <span class="st">&quot;WT&quot;</span> <span class="sc">&amp;</span> condition <span class="sc">==</span> <span class="st">&quot;RTD&quot;</span>) <span class="sc">%&gt;%</span></span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a>  <span class="fu">ad_ksample</span>(strength.norm, batch)</span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a><span class="co">#&gt; Call:</span></span>
<span id="cb9-6"><a href="#cb9-6" tabindex="-1"></a><span class="co">#&gt; ad_ksample(data = ., x = strength.norm, groups = batch)</span></span>
<span id="cb9-7"><a href="#cb9-7" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb9-8"><a href="#cb9-8" tabindex="-1"></a><span class="co">#&gt; N = 28           k = 3            </span></span>
<span id="cb9-9"><a href="#cb9-9" tabindex="-1"></a><span class="co">#&gt; ADK = 6.65       p-value = 0.0025892 </span></span>
<span id="cb9-10"><a href="#cb9-10" tabindex="-1"></a><span class="co">#&gt; Conclusion: Samples do not come from the same distribution (alpha = 0.025 )</span></span></code></pre></div>
<p>For the Anderson–Darling k-Sample test, <span class="math inline">\(\alpha=0.025\)</span> is normally used. In this
case the p-value is <span class="math inline">\(p=0.0026\)</span>, so it
is no where near <span class="math inline">\(\alpha\)</span> (note the
number of decimal places).</p>
<p>We can plot the distribution of this data and make a judgment call
about whether to continue.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a>norm_data <span class="sc">%&gt;%</span></span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>  <span class="fu">filter</span>(test <span class="sc">==</span> <span class="st">&quot;WT&quot;</span> <span class="sc">&amp;</span> condition <span class="sc">==</span> <span class="st">&quot;RTD&quot;</span>) <span class="sc">%&gt;%</span></span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a>  <span class="fu">group_by</span>(batch) <span class="sc">%&gt;%</span></span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> strength.norm, <span class="at">color =</span> batch)) <span class="sc">+</span></span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a>  <span class="fu">stat_normal_surv_func</span>() <span class="sc">+</span></span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a>  <span class="fu">stat_esf</span>() <span class="sc">+</span></span>
<span id="cb10-7"><a href="#cb10-7" tabindex="-1"></a>  <span class="fu">ggtitle</span>(<span class="st">&quot;Distribution of Data For Each Batch&quot;</span>)</span></code></pre></div>
<p><img role="img" src="data:image/png;base64,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" /><!-- --></p>
<p>We can also run the other diagnostic test by themselves. These are
described in more detail in the following sections.</p>
</div>
<div id="calculating-basis-values-by-pooling-across-environments" class="section level1">
<h1>Calculating Basis Values by Pooling Across Environments</h1>
<p>In this section, we’ll use the fill-compression data from the
<code>carbon.fabric.2</code> data set.</p>
<div id="checking-for-outliers" class="section level2">
<h2>Checking for Outliers</h2>
<p>After checking that there are a sufficient number of conditions,
batches and specimens and that the failure modes are consistent, we
would normally check if there are outliers within each batch and
condition. The maximum normed residual test can be used for this. The
<code>cmstatr</code> package provides the function
<code>maximum_normed_residual</code> to do this. First, we’ll group the
data by condition and batch, then run the test on each group. The
<code>maximum_normed_residual</code> function returns an object that
contains a number of values. We’ll create a <code>data.frame</code> that
contains those values.</p>
<p>In order to do this, we need to use the <code>nest</code> function
from the <code>tidyr</code> package. This is explained in detail <a href="https://tidyr.tidyverse.org/articles/nest.html">here</a>.
Basically, <code>nest</code> allows a column of <code>list</code>s or a
column of <code>data.frame</code>s to be added to a
<code>data.frame</code>. Once nested, we can use the <code>glance</code>
method to unpack the values returned by
<code>maximum_normed_residual</code> into a one-row
<code>data.frame</code>, and then use <code>unnest</code> to flatten
this into a single <code>data.frame</code>.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a>norm_data <span class="sc">%&gt;%</span></span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>  <span class="fu">filter</span>(test <span class="sc">==</span> <span class="st">&quot;FC&quot;</span>) <span class="sc">%&gt;%</span></span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a>  <span class="fu">group_by</span>(condition, batch) <span class="sc">%&gt;%</span></span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a>  <span class="fu">nest</span>() <span class="sc">%&gt;%</span></span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">mnr =</span> <span class="fu">map</span>(data,</span>
<span id="cb11-6"><a href="#cb11-6" tabindex="-1"></a>                   <span class="sc">~</span><span class="fu">maximum_normed_residual</span>(<span class="at">data =</span> .x, <span class="at">x =</span> strength.norm)),</span>
<span id="cb11-7"><a href="#cb11-7" tabindex="-1"></a>         <span class="at">tidied =</span> <span class="fu">map</span>(mnr, glance)) <span class="sc">%&gt;%</span></span>
<span id="cb11-8"><a href="#cb11-8" tabindex="-1"></a>  <span class="fu">select</span>(<span class="sc">-</span><span class="fu">c</span>(mnr, data)) <span class="sc">%&gt;%</span>  <span class="co"># remove unneeded columns</span></span>
<span id="cb11-9"><a href="#cb11-9" tabindex="-1"></a>  <span class="fu">unnest</span>(tidied)</span>
<span id="cb11-10"><a href="#cb11-10" tabindex="-1"></a><span class="co">#&gt; # A tibble: 15 × 6</span></span>
<span id="cb11-11"><a href="#cb11-11" tabindex="-1"></a><span class="co">#&gt; # Groups:   condition, batch [15]</span></span>
<span id="cb11-12"><a href="#cb11-12" tabindex="-1"></a><span class="co">#&gt;    condition batch   mnr alpha  crit n_outliers</span></span>
<span id="cb11-13"><a href="#cb11-13" tabindex="-1"></a><span class="co">#&gt;    &lt;chr&gt;     &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt;</span></span>
<span id="cb11-14"><a href="#cb11-14" tabindex="-1"></a><span class="co">#&gt;  1 CTD       A      1.48  0.05  1.89          0</span></span>
<span id="cb11-15"><a href="#cb11-15" tabindex="-1"></a><span class="co">#&gt;  2 CTD       B      1.72  0.05  1.89          0</span></span>
<span id="cb11-16"><a href="#cb11-16" tabindex="-1"></a><span class="co">#&gt;  3 CTD       C      1.52  0.05  1.89          0</span></span>
<span id="cb11-17"><a href="#cb11-17" tabindex="-1"></a><span class="co">#&gt;  4 RTD       A      1.34  0.05  1.89          0</span></span>
<span id="cb11-18"><a href="#cb11-18" tabindex="-1"></a><span class="co">#&gt;  5 RTD       B      1.47  0.05  1.89          0</span></span>
<span id="cb11-19"><a href="#cb11-19" tabindex="-1"></a><span class="co">#&gt;  6 RTD       C      1.52  0.05  1.89          0</span></span>
<span id="cb11-20"><a href="#cb11-20" tabindex="-1"></a><span class="co">#&gt;  7 ETD       A      1.66  0.05  1.89          0</span></span>
<span id="cb11-21"><a href="#cb11-21" tabindex="-1"></a><span class="co">#&gt;  8 ETD       B      1.53  0.05  1.89          0</span></span>
<span id="cb11-22"><a href="#cb11-22" tabindex="-1"></a><span class="co">#&gt;  9 ETD       C      1.40  0.05  1.89          0</span></span>
<span id="cb11-23"><a href="#cb11-23" tabindex="-1"></a><span class="co">#&gt; 10 ETW       A      1.45  0.05  1.89          0</span></span>
<span id="cb11-24"><a href="#cb11-24" tabindex="-1"></a><span class="co">#&gt; 11 ETW       B      1.83  0.05  1.89          0</span></span>
<span id="cb11-25"><a href="#cb11-25" tabindex="-1"></a><span class="co">#&gt; 12 ETW       C      1.76  0.05  1.89          0</span></span>
<span id="cb11-26"><a href="#cb11-26" tabindex="-1"></a><span class="co">#&gt; 13 ETW2      A      1.85  0.05  1.89          0</span></span>
<span id="cb11-27"><a href="#cb11-27" tabindex="-1"></a><span class="co">#&gt; 14 ETW2      B      1.54  0.05  1.89          0</span></span>
<span id="cb11-28"><a href="#cb11-28" tabindex="-1"></a><span class="co">#&gt; 15 ETW2      C      1.38  0.05  2.02          0</span></span></code></pre></div>
<p>None of the groups have outliers, so we can continue.</p>
</div>
</div>
<div id="batch-to-batch-distribution" class="section level1">
<h1>Batch-to-Batch Distribution</h1>
<p>Next, we will use the Anderson–Darling k-Sample test to check that
each batch comes from the same distribution within each condition. We
can use the <code>ad_ksample</code> function from <code>cmstatr</code>
to do so. Once again, we’ll use <code>nest</code>/<code>unnest</code>
and <code>glance</code> to do so.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a>norm_data <span class="sc">%&gt;%</span></span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a>  <span class="fu">filter</span>(test <span class="sc">==</span> <span class="st">&quot;FC&quot;</span>) <span class="sc">%&gt;%</span></span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a>  <span class="fu">group_by</span>(condition) <span class="sc">%&gt;%</span></span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a>  <span class="fu">nest</span>() <span class="sc">%&gt;%</span></span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">adk =</span> <span class="fu">map</span>(data, <span class="sc">~</span><span class="fu">ad_ksample</span>(<span class="at">data =</span> .x,</span>
<span id="cb12-6"><a href="#cb12-6" tabindex="-1"></a>                                     <span class="at">x =</span> strength.norm,</span>
<span id="cb12-7"><a href="#cb12-7" tabindex="-1"></a>                                     <span class="at">groups =</span> batch)),</span>
<span id="cb12-8"><a href="#cb12-8" tabindex="-1"></a>         <span class="at">tidied =</span> <span class="fu">map</span>(adk, glance)) <span class="sc">%&gt;%</span></span>
<span id="cb12-9"><a href="#cb12-9" tabindex="-1"></a>  <span class="fu">select</span>(<span class="sc">-</span><span class="fu">c</span>(data, adk)) <span class="sc">%&gt;%</span>  <span class="co"># remove unneeded columns</span></span>
<span id="cb12-10"><a href="#cb12-10" tabindex="-1"></a>  <span class="fu">unnest</span>(tidied)</span>
<span id="cb12-11"><a href="#cb12-11" tabindex="-1"></a><span class="co">#&gt; # A tibble: 5 × 8</span></span>
<span id="cb12-12"><a href="#cb12-12" tabindex="-1"></a><span class="co">#&gt; # Groups:   condition [5]</span></span>
<span id="cb12-13"><a href="#cb12-13" tabindex="-1"></a><span class="co">#&gt;   condition alpha     n     k sigma    ad     p reject_same_dist</span></span>
<span id="cb12-14"><a href="#cb12-14" tabindex="-1"></a><span class="co">#&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt;           </span></span>
<span id="cb12-15"><a href="#cb12-15" tabindex="-1"></a><span class="co">#&gt; 1 CTD       0.025    18     3 0.944 1.76  0.505 FALSE           </span></span>
<span id="cb12-16"><a href="#cb12-16" tabindex="-1"></a><span class="co">#&gt; 2 RTD       0.025    18     3 0.944 1.03  0.918 FALSE           </span></span>
<span id="cb12-17"><a href="#cb12-17" tabindex="-1"></a><span class="co">#&gt; 3 ETD       0.025    18     3 0.944 0.683 0.997 FALSE           </span></span>
<span id="cb12-18"><a href="#cb12-18" tabindex="-1"></a><span class="co">#&gt; 4 ETW       0.025    18     3 0.944 0.93  0.954 FALSE           </span></span>
<span id="cb12-19"><a href="#cb12-19" tabindex="-1"></a><span class="co">#&gt; 5 ETW2      0.025    19     3 0.951 1.74  0.513 FALSE</span></span></code></pre></div>
<p>For all conditions, the Anderson–Darling k-Sample test fails to
reject the hypothesis that each batch comes from the same (unspecified)
distribution. We can thus proceed to pooling the data.</p>
<div id="checking-for-outliers-within-each-condition" class="section level2">
<h2>Checking for Outliers Within Each Condition</h2>
<p>Just as we did when checking for outlier within each condition and
each batch, we can pool all the batches (within each condition) and
check for outliers within each condition.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a>norm_data <span class="sc">%&gt;%</span></span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a>  <span class="fu">filter</span>(test <span class="sc">==</span> <span class="st">&quot;FC&quot;</span>) <span class="sc">%&gt;%</span></span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a>  <span class="fu">group_by</span>(condition) <span class="sc">%&gt;%</span></span>
<span id="cb13-4"><a href="#cb13-4" tabindex="-1"></a>  <span class="fu">nest</span>() <span class="sc">%&gt;%</span></span>
<span id="cb13-5"><a href="#cb13-5" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">mnr =</span> <span class="fu">map</span>(data, <span class="sc">~</span><span class="fu">maximum_normed_residual</span>(<span class="at">data =</span> .x,</span>
<span id="cb13-6"><a href="#cb13-6" tabindex="-1"></a>                                                  <span class="at">x =</span> strength.norm)),</span>
<span id="cb13-7"><a href="#cb13-7" tabindex="-1"></a>         <span class="at">tidied =</span> <span class="fu">map</span>(mnr, glance)) <span class="sc">%&gt;%</span></span>
<span id="cb13-8"><a href="#cb13-8" tabindex="-1"></a>  <span class="fu">select</span>(<span class="sc">-</span><span class="fu">c</span>(mnr, data)) <span class="sc">%&gt;%</span>  <span class="co"># remove unneeded columns</span></span>
<span id="cb13-9"><a href="#cb13-9" tabindex="-1"></a>  <span class="fu">unnest</span>(tidied)</span>
<span id="cb13-10"><a href="#cb13-10" tabindex="-1"></a><span class="co">#&gt; # A tibble: 5 × 5</span></span>
<span id="cb13-11"><a href="#cb13-11" tabindex="-1"></a><span class="co">#&gt; # Groups:   condition [5]</span></span>
<span id="cb13-12"><a href="#cb13-12" tabindex="-1"></a><span class="co">#&gt;   condition   mnr alpha  crit n_outliers</span></span>
<span id="cb13-13"><a href="#cb13-13" tabindex="-1"></a><span class="co">#&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt;</span></span>
<span id="cb13-14"><a href="#cb13-14" tabindex="-1"></a><span class="co">#&gt; 1 CTD        2.38  0.05  2.65          0</span></span>
<span id="cb13-15"><a href="#cb13-15" tabindex="-1"></a><span class="co">#&gt; 2 RTD        2.06  0.05  2.65          0</span></span>
<span id="cb13-16"><a href="#cb13-16" tabindex="-1"></a><span class="co">#&gt; 3 ETD        2.05  0.05  2.65          0</span></span>
<span id="cb13-17"><a href="#cb13-17" tabindex="-1"></a><span class="co">#&gt; 4 ETW        2.34  0.05  2.65          0</span></span>
<span id="cb13-18"><a href="#cb13-18" tabindex="-1"></a><span class="co">#&gt; 5 ETW2       2.07  0.05  2.68          0</span></span></code></pre></div>
<p>We find no outliers, so we can continue.</p>
</div>
<div id="investigation-conditions" class="section level2">
<h2>Investigation Conditions</h2>
<p>When multiple conditions were tested, it’s usually useful to view
some basic summary statistics for each condition before proceeding. The
<code>condition_summary</code> function can be used for this. You can
pass a <code>data.frame</code> with the data and the name of the
condition variable to generate such summary statistics.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a>norm_data <span class="sc">%&gt;%</span></span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a>  <span class="fu">filter</span>(test <span class="sc">==</span> <span class="st">&quot;FC&quot;</span>) <span class="sc">%&gt;%</span></span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a>  <span class="fu">condition_summary</span>(strength.norm, condition, <span class="st">&quot;RTD&quot;</span>)</span>
<span id="cb14-4"><a href="#cb14-4" tabindex="-1"></a><span class="co">#&gt;   condition  n     mean mean_fraction</span></span>
<span id="cb14-5"><a href="#cb14-5" tabindex="-1"></a><span class="co">#&gt; 1       CTD 18 96.41519     1.0877571</span></span>
<span id="cb14-6"><a href="#cb14-6" tabindex="-1"></a><span class="co">#&gt; 2       RTD 18 88.63668     1.0000000</span></span>
<span id="cb14-7"><a href="#cb14-7" tabindex="-1"></a><span class="co">#&gt; 3       ETD 18 75.40668     0.8507390</span></span>
<span id="cb14-8"><a href="#cb14-8" tabindex="-1"></a><span class="co">#&gt; 4       ETW 18 58.28060     0.6575223</span></span>
<span id="cb14-9"><a href="#cb14-9" tabindex="-1"></a><span class="co">#&gt; 5      ETW2 19 51.87082     0.5852071</span></span></code></pre></div>
</div>
<div id="pooling-across-environments" class="section level2">
<h2>Pooling Across Environments</h2>
<p>Often it is desirable to pool data across several environments. There
are two methods for doing so: “pooled standard deviation” and “pooled
CV” (CV is an abbreviation for Coefficient of Variation).</p>
<p>First, we will check for equality of variance among the conditions.
We will do so using Levene’s test. The <code>cmstatr</code> package
provides the function <code>levene_test</code> to do so.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a>norm_data <span class="sc">%&gt;%</span></span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a>  <span class="fu">filter</span>(test <span class="sc">==</span> <span class="st">&quot;FC&quot;</span>) <span class="sc">%&gt;%</span></span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a>  <span class="fu">levene_test</span>(strength.norm, condition)</span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a><span class="co">#&gt; Call:</span></span>
<span id="cb15-6"><a href="#cb15-6" tabindex="-1"></a><span class="co">#&gt; levene_test(data = ., x = strength.norm, groups = condition)</span></span>
<span id="cb15-7"><a href="#cb15-7" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb15-8"><a href="#cb15-8" tabindex="-1"></a><span class="co">#&gt; n = 91           k = 5            </span></span>
<span id="cb15-9"><a href="#cb15-9" tabindex="-1"></a><span class="co">#&gt; F = 5.260731     p-value = 0.0007727083 </span></span>
<span id="cb15-10"><a href="#cb15-10" tabindex="-1"></a><span class="co">#&gt; Conclusion: Samples have unequal variance ( alpha = 0.05 )</span></span></code></pre></div>
<p>The result from Levene’s test indicates that the variance for each
condition is not equal. This indicates that the data cannot be pooled
using the “pooled standard deviation” method.</p>
<p>We can check if the data can be pooled using the “pooled CV” method.
We’ll start by normalizing the data from each group to the group’s mean.
The <code>cmstatr</code> package provides the function
<code>normalize_group_mean</code> for this purpose.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a>norm_data <span class="sc">%&gt;%</span></span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a>  <span class="fu">filter</span>(test <span class="sc">==</span> <span class="st">&quot;FC&quot;</span>) <span class="sc">%&gt;%</span></span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a>  <span class="fu">mutate</span>(</span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a>    <span class="at">strength_norm_group =</span> <span class="fu">normalize_group_mean</span>(strength.norm, condition)) <span class="sc">%&gt;%</span></span>
<span id="cb16-5"><a href="#cb16-5" tabindex="-1"></a>  <span class="fu">levene_test</span>(strength_norm_group, condition)</span>
<span id="cb16-6"><a href="#cb16-6" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb16-7"><a href="#cb16-7" tabindex="-1"></a><span class="co">#&gt; Call:</span></span>
<span id="cb16-8"><a href="#cb16-8" tabindex="-1"></a><span class="co">#&gt; levene_test(data = ., x = strength_norm_group, groups = condition)</span></span>
<span id="cb16-9"><a href="#cb16-9" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb16-10"><a href="#cb16-10" tabindex="-1"></a><span class="co">#&gt; n = 91           k = 5            </span></span>
<span id="cb16-11"><a href="#cb16-11" tabindex="-1"></a><span class="co">#&gt; F = 1.839645     p-value = 0.1285863 </span></span>
<span id="cb16-12"><a href="#cb16-12" tabindex="-1"></a><span class="co">#&gt; Conclusion: Samples have equal variances ( alpha = 0.05 )</span></span></code></pre></div>
<p>The Levene’s test thus shows the variances of the pooled data are
equal. We can move on to performing an Anderson–Darling test for
normality on the pooled data.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a>norm_data <span class="sc">%&gt;%</span></span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a>  <span class="fu">filter</span>(test <span class="sc">==</span> <span class="st">&quot;FC&quot;</span>) <span class="sc">%&gt;%</span></span>
<span id="cb17-3"><a href="#cb17-3" tabindex="-1"></a>  <span class="fu">mutate</span>(</span>
<span id="cb17-4"><a href="#cb17-4" tabindex="-1"></a>    <span class="at">strength_norm_group =</span> <span class="fu">normalize_group_mean</span>(strength.norm, condition)) <span class="sc">%&gt;%</span></span>
<span id="cb17-5"><a href="#cb17-5" tabindex="-1"></a>  <span class="fu">anderson_darling_normal</span>(strength_norm_group)</span>
<span id="cb17-6"><a href="#cb17-6" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb17-7"><a href="#cb17-7" tabindex="-1"></a><span class="co">#&gt; Call:</span></span>
<span id="cb17-8"><a href="#cb17-8" tabindex="-1"></a><span class="co">#&gt; anderson_darling_normal(data = ., x = strength_norm_group)</span></span>
<span id="cb17-9"><a href="#cb17-9" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb17-10"><a href="#cb17-10" tabindex="-1"></a><span class="co">#&gt; Distribution:  Normal ( n = 91 ) </span></span>
<span id="cb17-11"><a href="#cb17-11" tabindex="-1"></a><span class="co">#&gt; Test statistic:  A = 0.3619689 </span></span>
<span id="cb17-12"><a href="#cb17-12" tabindex="-1"></a><span class="co">#&gt; OSL (p-value):  0.3812268  (assuming unknown parameters)</span></span>
<span id="cb17-13"><a href="#cb17-13" tabindex="-1"></a><span class="co">#&gt; Conclusion: Sample is drawn from a Normal distribution ( alpha = 0.05 )</span></span></code></pre></div>
<p>The Anderson–Darling test indicates that the pooled data is drawn
from a normal distribution, so we can continue with calculating basis
values using the “pooled CV” method.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a>norm_data <span class="sc">%&gt;%</span></span>
<span id="cb18-2"><a href="#cb18-2" tabindex="-1"></a>  <span class="fu">filter</span>(test <span class="sc">==</span> <span class="st">&quot;FC&quot;</span>) <span class="sc">%&gt;%</span></span>
<span id="cb18-3"><a href="#cb18-3" tabindex="-1"></a>  <span class="fu">basis_pooled_cv</span>(strength.norm, condition, batch)</span>
<span id="cb18-4"><a href="#cb18-4" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb18-5"><a href="#cb18-5" tabindex="-1"></a><span class="co">#&gt; Call:</span></span>
<span id="cb18-6"><a href="#cb18-6" tabindex="-1"></a><span class="co">#&gt; basis_pooled_cv(data = ., x = strength.norm, groups = condition, </span></span>
<span id="cb18-7"><a href="#cb18-7" tabindex="-1"></a><span class="co">#&gt;     batch = batch)</span></span>
<span id="cb18-8"><a href="#cb18-8" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb18-9"><a href="#cb18-9" tabindex="-1"></a><span class="co">#&gt; Distribution:  Normal - Pooled CV    ( n = 91, r = 5 )</span></span>
<span id="cb18-10"><a href="#cb18-10" tabindex="-1"></a><span class="co">#&gt; B-Basis:   ( p = 0.9 , conf = 0.95 )</span></span>
<span id="cb18-11"><a href="#cb18-11" tabindex="-1"></a><span class="co">#&gt; CTD   85.09241 </span></span>
<span id="cb18-12"><a href="#cb18-12" tabindex="-1"></a><span class="co">#&gt; ETD   66.55109 </span></span>
<span id="cb18-13"><a href="#cb18-13" tabindex="-1"></a><span class="co">#&gt; ETW   51.43626 </span></span>
<span id="cb18-14"><a href="#cb18-14" tabindex="-1"></a><span class="co">#&gt; ETW2  45.81318 </span></span>
<span id="cb18-15"><a href="#cb18-15" tabindex="-1"></a><span class="co">#&gt; RTD   78.2274</span></span></code></pre></div>
<p>The conditions listed in the output above are in alphabetical order.
This probably isn’t what you want. Instead, you probably want the
conditions listed in a certain order. This can be done by ordering the
data first as demonstrated below. You’re probably just do this one in at
the start of your analysis. In the example below, we’ll store the result
in the variable <code>basis_res</code> before printing it.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a>basis_res <span class="ot">&lt;-</span> norm_data <span class="sc">%&gt;%</span></span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">condition =</span> <span class="fu">ordered</span>(condition,</span>
<span id="cb19-3"><a href="#cb19-3" tabindex="-1"></a>                             <span class="fu">c</span>(<span class="st">&quot;CTD&quot;</span>, <span class="st">&quot;RTD&quot;</span>, <span class="st">&quot;ETD&quot;</span>, <span class="st">&quot;ETW&quot;</span>, <span class="st">&quot;ETW2&quot;</span>))) <span class="sc">%&gt;%</span></span>
<span id="cb19-4"><a href="#cb19-4" tabindex="-1"></a>  <span class="fu">filter</span>(test <span class="sc">==</span> <span class="st">&quot;FC&quot;</span>) <span class="sc">%&gt;%</span></span>
<span id="cb19-5"><a href="#cb19-5" tabindex="-1"></a>  <span class="fu">basis_pooled_cv</span>(strength.norm, condition, batch)</span>
<span id="cb19-6"><a href="#cb19-6" tabindex="-1"></a>basis_res</span>
<span id="cb19-7"><a href="#cb19-7" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb19-8"><a href="#cb19-8" tabindex="-1"></a><span class="co">#&gt; Call:</span></span>
<span id="cb19-9"><a href="#cb19-9" tabindex="-1"></a><span class="co">#&gt; basis_pooled_cv(data = ., x = strength.norm, groups = condition, </span></span>
<span id="cb19-10"><a href="#cb19-10" tabindex="-1"></a><span class="co">#&gt;     batch = batch)</span></span>
<span id="cb19-11"><a href="#cb19-11" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb19-12"><a href="#cb19-12" tabindex="-1"></a><span class="co">#&gt; Distribution:  Normal - Pooled CV    ( n = 91, r = 5 )</span></span>
<span id="cb19-13"><a href="#cb19-13" tabindex="-1"></a><span class="co">#&gt; B-Basis:   ( p = 0.9 , conf = 0.95 )</span></span>
<span id="cb19-14"><a href="#cb19-14" tabindex="-1"></a><span class="co">#&gt; CTD   85.09241 </span></span>
<span id="cb19-15"><a href="#cb19-15" tabindex="-1"></a><span class="co">#&gt; RTD   78.2274 </span></span>
<span id="cb19-16"><a href="#cb19-16" tabindex="-1"></a><span class="co">#&gt; ETD   66.55109 </span></span>
<span id="cb19-17"><a href="#cb19-17" tabindex="-1"></a><span class="co">#&gt; ETW   51.43626 </span></span>
<span id="cb19-18"><a href="#cb19-18" tabindex="-1"></a><span class="co">#&gt; ETW2  45.81318</span></span></code></pre></div>
<p>The summary statistics that we computed for each condition earlier
can also be generated using the <code>basis</code> object returned by
<code>basis_pooled_cv</code> and related functions.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a>basis_res <span class="sc">%&gt;%</span></span>
<span id="cb20-2"><a href="#cb20-2" tabindex="-1"></a>  <span class="fu">condition_summary</span>(<span class="st">&quot;RTD&quot;</span>)</span>
<span id="cb20-3"><a href="#cb20-3" tabindex="-1"></a><span class="co">#&gt;   condition  n     mean mean_fraction    basis basis_fraction</span></span>
<span id="cb20-4"><a href="#cb20-4" tabindex="-1"></a><span class="co">#&gt; 1       CTD 18 96.41519     1.0877571 85.09241      1.0877571</span></span>
<span id="cb20-5"><a href="#cb20-5" tabindex="-1"></a><span class="co">#&gt; 2       RTD 18 88.63668     1.0000000 78.22740      1.0000000</span></span>
<span id="cb20-6"><a href="#cb20-6" tabindex="-1"></a><span class="co">#&gt; 3       ETD 18 75.40668     0.8507390 66.55109      0.8507390</span></span>
<span id="cb20-7"><a href="#cb20-7" tabindex="-1"></a><span class="co">#&gt; 4       ETW 18 58.28060     0.6575223 51.43626      0.6575223</span></span>
<span id="cb20-8"><a href="#cb20-8" tabindex="-1"></a><span class="co">#&gt; 5      ETW2 19 51.87082     0.5852071 45.81318      0.5856412</span></span></code></pre></div>
</div>
</div>
<div id="equivalency" class="section level1">
<h1>Equivalency</h1>
<p>Eventually, once you’ve finished calculating all your basis values,
you’ll probably want to set specification requirements or evaluate
site/process equivalency. <code>cmstatr</code> has functionality to do
both.</p>
<p>Let’s say that you want to develop specification limits for fill
compression that you’re going to put in your material specification. You
can do this as follows:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a>carbon.fabric<span class="fl">.2</span> <span class="sc">%&gt;%</span></span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a>  <span class="fu">filter</span>(test <span class="sc">==</span> <span class="st">&quot;FC&quot;</span> <span class="sc">&amp;</span> condition <span class="sc">==</span> <span class="st">&quot;RTD&quot;</span>) <span class="sc">%&gt;%</span></span>
<span id="cb21-3"><a href="#cb21-3" tabindex="-1"></a>  <span class="fu">equiv_mean_extremum</span>(strength, <span class="at">n_sample =</span> <span class="dv">5</span>, <span class="at">alpha =</span> <span class="fl">0.01</span>)</span>
<span id="cb21-4"><a href="#cb21-4" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb21-5"><a href="#cb21-5" tabindex="-1"></a><span class="co">#&gt; Call:</span></span>
<span id="cb21-6"><a href="#cb21-6" tabindex="-1"></a><span class="co">#&gt; equiv_mean_extremum(df_qual = ., data_qual = strength, n_sample = 5, </span></span>
<span id="cb21-7"><a href="#cb21-7" tabindex="-1"></a><span class="co">#&gt;     alpha = 0.01)</span></span>
<span id="cb21-8"><a href="#cb21-8" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb21-9"><a href="#cb21-9" tabindex="-1"></a><span class="co">#&gt; For alpha = 0.01 and n = 5 </span></span>
<span id="cb21-10"><a href="#cb21-10" tabindex="-1"></a><span class="co">#&gt; ( k1 = 3.071482 and k2 = 1.142506 )</span></span>
<span id="cb21-11"><a href="#cb21-11" tabindex="-1"></a><span class="co">#&gt;                   Min Individual    Sample Mean    </span></span>
<span id="cb21-12"><a href="#cb21-12" tabindex="-1"></a><span class="co">#&gt;      Thresholds:     69.89842         82.16867</span></span></code></pre></div>
<p>If you’re determining equivalency limits for modulus, a different
approach is generally used so that bilateral limits are set.
<code>cmstatr</code> can do this as well, using the function
<code>equiv_change_mean</code>.</p>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
